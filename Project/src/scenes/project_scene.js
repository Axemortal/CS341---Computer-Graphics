// src/scenes/city_scene.js
import { TurntableCamera } from "../scene_resources/camera.js";
import * as MATERIALS from "../render/materials.js";
import { ResourceManager } from "../scene_resources/resource_manager.js";
import { makeSphereUV } from "../cg_libraries/cg_mesh.js";
import { runWFC } from '../scene_resources/wfc_solver.js';
import { Scene } from "./scene.js";
import { quat } from "../../lib/gl-matrix_3.3.0/esm/index.js";

export class ProjectScene extends Scene {
  /**
   * A scene featuring reflective water body and a WFC-generated building
   * @param {ResourceManager} resource_manager
   */
  constructor(resource_manager) {
    super();
    this.resource_manager = resource_manager;
    this.static_objects = [];
    this.dynamic_objects = [];

    this.initialize_scene().then(() => {
      this.objects = this.static_objects.concat(this.dynamic_objects);
    });
    this.lights = [];
    this.UIParams.renderTexture = null;
    this.initialize_actor_actions();
  }

  async initialize_scene() {
    const identityRot = [0, 0, 0, 1];

    // Sky dome
    this.resource_manager.addProceduralMesh(
      "mesh_sphere_env_map",
      makeSphereUV(16)
    );
    this.static_objects.push({
      translation: [0, 0, 0],
      scale: [100, 100, 100],
      rotation: identityRot,
      meshReference: 'mesh_sphere_env_map',
      material: MATERIALS.sunset_sky
    });

    // Static reflective water plane and donut
    let rotationQuat = quat.create();
    quat.fromEuler(rotationQuat, 90, 0, 0);

    this.dynamic_objects.push({
      translation: [0, 2, 2],
      scale: [1, 1, 1],
      rotation: rotationQuat,
      meshReference: "donut.obj",
      material: MATERIALS.BasicColors.gray,
    });

    this.dynamic_objects.push({
      translation: [0, 0, 0],
      scale: [10, 1, 10],
      rotation: rotationQuat,
      meshReference: "plane.obj",
      material: MATERIALS.mirror,
    });

    const pine_positions = [
      [-3, 4, 0.3],
      [3, 5, 0.3],
      [0, 7, 0.3],
    ];
    const pine_materials = [
      MATERIALS.BasicColors.red,
      MATERIALS.BasicColors.blue,
      MATERIALS.pine,
    ];

    for (let i = 0; i < pine_positions.length; i++) {
      this.dynamic_objects.push({
        translation: pine_positions[i],
        scale: [0.8, 0.8, 0.8],
        rotation: identityRot,
        meshReference: "pine.obj",
        material: pine_materials[i],
      });
    }

    // === BUILDING GENERATED BY WFC ===
    const offset = [5, -5, 0];
    const dims = [6, 6, 8];
    const [sizeX, sizeY, sizeZ] = dims;
    const grid = await runWFC(sizeX, sizeY, sizeZ);

    const box = {
      minX: Infinity, maxX: -Infinity,
      minY: Infinity, maxY: -Infinity,
      minZ: Infinity, maxZ: -Infinity
    };

    for (let x = 0; x < grid.length; x++) {
      for (let y = 0; y < grid[x].length; y++) {
        for (let z = 0; z < grid[x][y].length; z++) {
          const tile = grid[x][y][z];
          if (!tile) continue;

          const wx = offset[0] + x;
          const wy = offset[1] + y;
          const wz = offset[2] + z;

          box.minX = Math.min(box.minX, wx);
          box.maxX = Math.max(box.maxX, wx);
          box.minY = Math.min(box.minY, wy);
          box.maxY = Math.max(box.maxY, wy);
          box.minZ = Math.min(box.minZ, wz);
          box.maxZ = Math.max(box.maxZ, wz);

          this.dynamic_objects.push({
            translation: [wx, wy, wz],
            scale: [1, 1, 1],
            rotation: identityRot,
            meshReference: tile.model,
            material: MATERIALS.concrete,
          });
        }
      }
    }

    const cx = (box.minX + box.maxX) / 2;
    const cy = (box.minY + box.maxY) / 2;
    const cz = box.maxZ;
    this.lights.push({ position: [cx, cy, cz + 4], color: [0.8, 0.8, 0.8] });
  }

  initialize_actor_actions() {}
  initialize_ui_params() {}
}
